[if cgi junksubmit]
[or cgi cancelsubmit]
Hit action for no-content
[tag op=header]Status: 204 No content[/tag]
[goto]
[/if]

[set page_title][L]Menu construction[/L][/set]
[tmpn dhtml_required]1[/tmpn]
[set ui_class]Design[/set]
[if cgi qmenu_separate]
[cgi name=qmenu_products set="[cgi qmenu_separate]" hide=1]
[/if]
[if cgi qmenu_name]
[seti page_banner][msg arg.0="<i>[cgi qmenu_name]</i>"]Edit the %s menu[/msg][/seti]
[else]
[set page_banner][L]Menu constructor: Make a quick menu[/L][/set]
[/else]
[/if]
[tmpn check_publish]1[/tmpn]
[set page_perm]layout=e[/set]
[set help_name]menu.edit[/set]
[set icon_name]icon_pages.gif[/set]
[seti ui_body_extra][/seti]
[tmp meta_header]
        [include include/table_populator]
        <SCRIPT LANGUAGE=JavaScript>
	  function toggle_comb (toggle) {
                var el_comb = document.getElementById('combfield');
                var el_nocomb = document.getElementById('nocombfield');
                if(el_comb == undefined || el_nocomb == undefined)
                        return; 
		if (toggle == true) {
			el_comb.style.visibility = "Visible";			
			el_nocomb.style.visibility = "Hidden";			
		}
		else {
			el_comb.style.visibility = "Hidden";			
			el_nocomb.style.visibility = "Visible";			
		}
		return;
	  }
        </SCRIPT>
[/tmp]

@_UI_STD_HEAD_@
<!-- ----- BEGIN REAL STUFF ----- -->

[loop list="tree __MV_TREE_TABLE__"]
[flag type=write table="[loop-code]"]
[/loop]

[seti medit_tables]
__MV_TREE_TABLE__
__ProductFiles_0__
tree
cat
area
[cgi qmenu_products]
__UI_META_TABLE__
[/seti]

<script>
	var is_form_unpublished = 0;
</script>

[set qmenu_relocate][/set]
[perl tables="[scratch medit_tables]"]
	my $menupath = $Variable->{MV_MENU_DIRECTORY} || 'include/menus';
	@menufields = qw/
        code mgroup msort next_line indicator exclude_on depends_on page
        form name super inactive description help_name img_dn img_up
        img_sel img_icon url member
	/;

	$Tag->tmp('qmenu_fdata');
	$Tag->tmp('qmenu_data');
	%menuinit = (
				code => 0,
				inactive => 0,
				msort => "'x'",
				);

	if ($CGI->{qmenu_products} && $CGI->{qmenu_use_comb_field}) {
		# Build menu from a comb_category field ('Level 1:Level 2:Level 3...Level n')

		$CGI->{qmenu_comb_field} ||= 'comb_category';
		
		my %opt = (
			table => $CGI->{qmenu_products},
			comb_field => $CGI->{qmenu_comb_field},
			sort_string => $CGI->{qmenu_sort_string},
			sort_order => $CGI->{qmenu_sort_order},
			type => 'comb_category',
			even_large => $CGI->{qmenu_even_large},
		);

		$CGI->{qmenu_text} = $Tag->menu_load(\%opt);
		$CGI->{qmenu_name} = '';
		$CGI->{qmenu_new} = 'Untitled';
	}
	elsif ($CGI->{qmenu_products}) {
		# Build menu from prod_group and category fields

		$CGI->{qmenu_toplevel_field} ||= 'prod_group';
		$CGI->{qmenu_sublevel_field} ||= 'category';

		my %opt = (
			table => $CGI->{qmenu_products},
			first_field => $CGI->{qmenu_toplevel_field},
			second_field => $CGI->{qmenu_sublevel_field},
			desc_field => $CGI->{qmenu_desc_field},
			even_large => $CGI->{qmenu_even_large},
			sku_field => $CGI->{qmenu_sku_field},
			type => $CGI->{qmenu_load_type} || 'tree',
			no_leaves => $CGI->{qmenu_no_leaves},
		);

		$CGI->{qmenu_text} = $Tag->menu_load(\%opt);
		$CGI->{qmenu_name} = '';
		$CGI->{qmenu_new} = 'Untitled';
	}
	elsif ($CGI->{qmenu_cat}) {
		# Build menu from top&sub level tables
		if($CGI->{qmenu_sel_value} =~ /\S/) {
			$CGI->{qmenu_sel_value} =~ s/^\s+//;
			$CGI->{qmenu_sel_value} =~ s/\s+$//;
		}
		else {
			undef $CGI->{qmenu_sel_value};
		}

		$CGI->{qmenu_toplevel} ||= 'area';
		$CGI->{qmenu_sublevel} ||= 'cat';
		my %opt = (
			table => $CGI->{qmenu_toplevel},
			sel => $CGI->{qmenu_sel_value},
			cat_table => $CGI->{qmenu_sublevel},
			even_large => $CGI->{qmenu_even_large},
			type => 'cat_menu',
		);

		$CGI->{qmenu_text} = $Tag->menu_load(\%opt);
		$CGI->{qmenu_name} = '';
		$CGI->{qmenu_new} = 'Untitled';

	}

	if($CGI->{qmenu_text}) {
		my $menufile;
		my $menuname;
		if($CGI->{qmenu_new} =~ /\S/) {
			$menuname = $CGI->{qmenu_new};
			$menuname =~ s/\s+$//;
			$menuname =~ s/^\s+//;
		}
		else {
			$menuname = $CGI->{qmenu_name};
		}
		$CGI->{qmenu_name} = $menuname;
		if($menuname) {
			$menufile = $Tag->filter('filesafe', "$menupath/$menuname.txt");
			my $text = $CGI->{qmenu_text};

#Debug("qmenu text length=" . length($text));
#Debug("qmenu text value=$CGI->{qmenu_text}");
			$text =~ s{\\([\\r])}{
									if   ($1 eq 'r')  { "\r" }
									elsif($1 eq "\\") { "\\" }
									else              { "\\$1" }
								}eg;
			$text =~ s/\r\n/\n/g;
			$Tag->backup_file($menufile) if -f $menufile;
			if($Tag->write_relative_file($menufile, $text) ) {
				$Tag->warnings( errmsg(
									"Menu '%s' saved to file %s. Active on next access.",
									$menuname,
									$menufile,
								));
				$Scratch->{qmenu_relocate} = 1;
			}
			else {
				$Tag->error({ name => 'Save menu',
							  set => errmsg(
										"Failed to save menu '%s' to file %s.",
										$Tag->filter('urldecode', $menuname),
										$menufile,
									),
								});
			}
			my $tab = $Variable->{MV_TREE_TABLE} || 'tree';
			if($CGI->{qmenu_tree} && $CGI->{qmenu_write_tree} and $Db{$tab}) {
			  TREEWRITE: {
				my $db = $Db{$tab}
					or do {
						$Tag->error({
								set =>  errmsg(
											"%s database %s for tree write: %s",
											'open',
											$tab,
											'non-existent',
										),
								});
						last TREEWRITE;

					};
				my @lines = split /\n/, $text;
				my @fields = split /\t/, shift(@lines);
				my $pfield = $Variable->{MV_TREE_PARENT_FIELD} || 'parent_fld';
				my $gfield = $Variable->{MV_TREE_GROUP_FIELD} || 'mgroup';
				my $sfield = $Variable->{MV_TREE_SORT_FIELD} || 'msort';

				my @valid;
				for(my $i = 0; $i < @fields; $i++) {
					push @valid, $i if defined $db->test_column($fields[$i]);
				}
#Debug("valid entries=" . join(',', @valid));

				@fields = @fields[@valid];

				my $gptr;
				my $sptr;
				for(my $i = 1; $i < @fields; $i++) {
					if($fields[$i] eq $gfield) {
						$gptr = $i;
					}
					elsif($fields[$i] eq $sfield) {
						$sptr = $i;
					}
				}

				my $num = @fields;
				my $last = $num - 1;

				my $pptr = @fields;
				push @fields, $pfield;
				shift(@fields);

				my @parent = ($menuname);
				my $plev = 0;

				my $query = qq{delete from $tab where $gfield = '$menuname'};
				$db->query($query);

				for(@lines) {
					my @row = split /\t/, $_, $num;
					my @f = @fields;
					$#row = $last;
					@row = @row[@valid];
					my $lev = $row[$sptr];
#Debug("menu level=$lev");
					$row[$gptr] = $menuname;
					$row[$pptr] = $parent[$lev];
					splice(@parent, $lev + 1);
					shift(@row);
#Debug("fields to set: " . uneval(\@f));
#Debug("values to set: " . uneval(\@row));
					my $key = $db->set_slice(undef, \@f, \@row);
#Debug("fields to set: " . uneval(\@f));
#Debug("values to set: " . uneval(\@row));
					$parent[$lev + 1] = $key;
				}
				$Tag->warnings( errmsg(
									"Successfully wrote %s lines to tree %s.",
									scalar(@lines),
									$menuname,
								) );
			  }
			}
		}
		else {
			$Tag->error({	name => 'qmenu_name/qmenu_new',
							set => "No menu name to write.",
						});
		}
	}

	if($CGI->{qmenu_html_create} and $CGI->{qmenu_create}) {
		my $text = $CGI->{qmenu_html_create};
		my $num_options;
		my $num_links;
		$num_options++ while $text =~ m{<option\s+}gi;
		$num_links++   while $text =~ m{<a\s+}gi;
		my $start = '0001';
		my @out = join "\t", @menufields;

		if($num_options > $num_links) {
			while( $text =~ m{
					 <option\s+
						[^>]*
						value\s*=\s*"(.*?)"
						[^>]*
						>
						([^<>]*)
					}ixgs
				)
			{
				my $url = $1;
				my $anchor = $2;
				my $sort = $start;
				$sort =~ s/./x/;
				my($href, $parms) = split /\?/, $url, 2;
				my %record = (
					code => $start++,
					msort => $sort,
					page => $href,
					form => $parms,
					name => $anchor,
				);
				push @out, join "\t", @record{@menufields};
			}

		}
		else {
			while($text =~ s{<a(\s+.*?)</a>}{}is) {
				my $blob = $1;
				my $desc = '';
				$blob =~ m{^[^>]*\s+title=(['"]?)(.*?)\1}
					and $desc = $2;
				$blob =~ s{^.*?\shref\s*=\s*(["'])?(.*?)\1}{}is
					or next;
				my $link = $2;
				$blob =~ s/.*?>//;
				1 while $blob =~ s{<.*?>}{};
				$anchor = $blob;
				my $sort = $start;
				$sort =~ s/./x/;
				my($href, $parms) = split /\?/, $link, 2;
				my %record = (
					code => $start++,
					msort => $sort,
					page => $href,
					form => $parms,
					name => $anchor,
					description => $desc,
				);

				push @out, join "\t", @record{@menufields};
			}
		}

		$Scratch->{qmenu_data} = join "\n", @out, '';
		$CGI->{qmenu_name} = '';
		$CGI->{qmenu_new} ||= 'Untitled';
	}

	my $files = $Tag->list_pages({
											base => $menupath,
											ext => '.txt',
											arrayref => 1,
										});
#Debug("files=" . join(",", @$files));
	my @names;
	for(@$files) {
		my $tmp = $_;
		$tmp =~ s/%([A-Fa-f0-9]{2})/chr(hex $1)/eg;
		$_ = "$menupath/$_.txt";
		push @names, $tmp;
	}

	@qmenu{@names} = @$files;

	my @fdata = "code\tfile";
	for(my $i = 0; $i < @names; $i++) {
		push @fdata, "$names[$i]\t$files->[$i]";
	}
	$Scratch->{qmenu_fdata} = join "\n", @fdata;

	if(my $mn = $CGI->{qmenu_name}) {
		my $filedata = $Tag->file($qmenu{$mn});
		if(! $filedata) {
			$filedata = $Tag->file("$menupath/$mn.txt");
			## Aha, in admin include
			$CGI->{qmenu_new} ||= $mn;
		}

		if($filedata) {
			$filedata =~ /^(.*)/;
			my $f = $1;
			$f =~ s/\s+$//;
			@menufields = split /\t/, $f;
#Debug("menufields=" . join(",", @menufields));
		}
		else {
			$filedata = join("\t", @menufields);
		}
		$Scratch->{qmenu_data} = $filedata;
		$Scratch->{qmenu_name} = $mn;
		my $mbase;
		for $mbase ( $CGI->{ui_meta_view}, "menu_editor::$mn") {
			$menumeta = $Tag->meta_record($mbase)
				and $metabase = $mbase
					and last;
		}
	}

	my %illegal;
	my @illegal  = qw/check msg code/;
	my %suggested = qw/
                        extended 1
                        inactive 1
					/;
	my @required = qw/
                        description
                        form
                        mgroup
                        msort
                        name
                        page
					/;
	@required{@required} = @required;
	@illegal{@illegal} = @illegal;
	my $illegal = 0;
	for(my $i = 1; $i < @menufields; $i++) {
		my $f = lc $menufields[$i];
		$menu_fh{$f} = $i;
		delete $required{$f};
		delete $suggested{$f};
		if($illegal{$f}) {
			$Tag->error({
						name => 'Illegal field name',
						set => errmsg( "Name reserved: %s.", $f),
					});
			$illegal++;
		}
	}
	@suggested = keys %suggested;
	for(keys %required) {
			$Tag->error({
						set => errmsg( "Required field '%s' missing.", $_),
					});
			$illegal++;
	}
	delete $Scratch->{qmenu_data} if $illegal;
	@required{@required} = @required;
	return;
[/perl]

[tmp qmenu_options]
[loop head-skip=1 lr=1 list="[scratch qmenu_fdata]" cgi=1 option=qmenu_name]
<option value="[loop-code]">[loop-code]</option>
[/loop]
[/tmp]

[output name=search_box]
<form action="[area @@MV_PAGE@@]" style="margin: 0px; padding: 0px">
[form-session-id]
[tmp delete_loc][area href=admin/file_transfer form=| initial_dir=include/menus |][/tmp]
<input	type=button
		onClick="if(check_publish()) { location='[scratch delete_loc]' }"
		value="[L]Delete/Manage[/L]"
		class=s3>
<input name=mv_action type=hidden value="back">
&nbsp;
&nbsp;
<span class=s3>[L]Menu name[/L]</span>
<select name=qmenu_name
		onChange="if(check_publish()) { this.form.submit() }"
		class=s3><option value="" class=s3>[L]--select--[/L]</option>[scratch qmenu_options]</select>
<input	type=button
		name=submittor
		value="[L]Load[/L]"
		onClick="if(check_publish()) { this.form.submit() }"
		class=s3>
</form>
[output name=""]

[if scratch qmenu_relocate]
	[if cgi return_page]
	[deliver location="[area href='[cgi return_page]']" type="text/html"]
	[/if]
[/if]

<span class=cmessage>[warnings auto=1]</span>
[error all=1 text="<ul class=cerror><li>%s</ul>" joiner="<li>"]

<script>
var lines = new Array;
var toggle = new Array;
var initialized = 0;
var no_alert = 0;
var tree_mode = 0;
var extended;
var extra = new Array;
var label = new Array;
var meta = new Array;
var help = new Array;
var widget = new Array;
var ltitle = new Array;
var emodes;
var evalues;
var image_dir = '[image dir-only=1 ui=1 secure="__UI_SECURE__"]';
var empty_img    = image_dir + 'box_empty.gif';
var up_img       = image_dir + 'up.gif';
var down_img     = image_dir + 'down.gif';
var full_img     = image_dir + 'box_checked.gif';
var left_img     = image_dir + 'left.gif';
var right_img    = image_dir + 'right.gif';
var plus_img     = image_dir + 'tplus.gif';
var minus_img     = image_dir + 'tminus.gif';
var leaf_img     = image_dir + 'bg.gif';
var forward_img  = image_dir + 'forward.gif';
var transfer_img = image_dir + 'transfer.gif';

var plus_title = ' title="open tree branch" ';
var minus_title = ' title="close tree branch" ';
var up_title = ' title="Move checked tree branch or individual item up" ';
var down_title = ' title="Move checked tree branch or individual item down" ';
var left_title = ' title="move item (or items from here to checked item) left" ';
var right_title = ' title="move item (or items from here to checked item) right" ';
var transfer_title = ' title="load item into editor" ';
var forward_title = ' title="load item into editor" ';

[perl reparse=0]
my @out;
my $i = 0;

$metabase ||= 'icmenu';
for my $f (@menufields) {
	push @out, "    var \U$f\E = $i;";
	DOMETA: {
		last DOMETA if $required{$f} or $f eq 'code';
		my $metaname = "${metabase}::$f";
		my $mrecord = $Tag->meta_record($metaname)
			or last DOMETA;
		my $lab;
		my $help;
		if($lab = $mrecord->{label}) {
			push @out, "    label[$i] = " . $Tag->jsq($lab) . ';';
		}
		if($help = $mrecord->{help}) {
			$help = '<span style="font-size: 12pt;">' .
					'<u>' . "$lab " . "($f)" . '</u><br>' . $help .
					'</span>';
			$help = $Tag->filter('encode_entities', $help);
			push @out, "    help[$i] = " . $Tag->jsq($help) . ';';
		}
		if( defined $Values->{ui_meta_force} && $Values->{ui_meta_force}
			or $Variable->{UI_META_LINK}
		   )
		{
			my $u = $Tag->page({ href => '__UI_BASE__/meta_editor',
								form => qq(
									item_id=$metaname
								) });
			push @out, "    meta[$i] = " . $Tag->jsq($u . 'meta</a>');
		}
		if(my $type = $mrecord->{type}) {
			$mrecord->{name} = "ext_$f";
			$mrecord->{extra} = qq{onChange="form_changed(1)"};
			my $wid = $Tag->display( {
									meta => $mrecord,
									override => 1,
									default => '',
									} );
			push @out, "    widget[$i] = " . $Tag->jsq($wid) . ';';
		}
	}
	$i++;
}

for (@suggested) {
	push @out, "    var \U$_;";
}

$i = scalar(@menufields);
push @out, "\tvar CHECK = $i;";
$i++;
push @out, "\tvar MSG = $i;";

push @out, "\tlines[0] = ['" . join("', '", @menufields) . "'];";
#Debug("Generated code=" . join "\n", @out);
return join "\n", @out;
[/perl]

[restrict enable="perl calc scratch loop image area" log=none]
[loop head-skip=1 lr=1 list="[scratch qmenu_data]"][loop-sub jsline]
sub {
$loopname = shift;
my $row = shift;
$loopinc++;

while(@$row < @menufields) {
	push @$row, '';
}

if($CGI->{remap}) {
	my $tmp = $row->[$menu_fh{mgroup}];
	$row->[$menu_fh{mgroup}] = $row->[$menu_fh{msort}];
	$row->[$menu_fh{msort}] = $tmp;
}

my $i = 0;
for(@$row) {
	my $foundit = '';
	if($_ eq '0') {
		# Do nothing
	}
	elsif(/^[1-9](\d*\.)?\d*$/) {
		# Do nothing
	}
	elsif(! length($_) and exists $menuinit{$menufields[$i]}) {
		$_ = $menuinit{$menufields[$i]};
	}
	elsif($_ !~ /'/) {
		s/\r/\\r/g;
		$_ = "'$_'";
	}
	elsif($_ !~ /"/) {
		s/\r/\\r/g;
		$_ = qq{"$_"};
	}
	else {
		if(s/^\s*{\s+//) {
			s/(,?\s*\}\s*)$//;
			$foundit = 1;
		}
		s/\\'/-_ESC_QUOTE_-/g;
		s/'/\\'/g;
		s/\r+$/' + "\\r"/g;
		s/\r/' + "\\r" + '/g;
		s/-_ESC_QUOTE_-/\\\\\\'/g;
		if($foundit) {
			$_ = "{" . $_ . "}";
		}
		$_ = qq{'$_'};
	}
	$i++;
}
my $line = "$loopname\[" . $loopinc  . "] = [" . join(", ", @$row) . "];";
#Debug("Final line=$line");
return $line;
}
[/loop-sub][loop-exec jsline]lines[/loop-exec]
[/loop]
[calc]
$loopinc++;
$Scratch->{lastfull} = $loopinc;
my $stop = $loopinc + 50;
my @out;
for(; $loopinc < $stop; $loopinc++) {
	# do nothing
}
$Scratch->{loopinc} = $loopinc - 1;
return;
[/calc]


var is_form_changed = 0;
var checkcur = 0;
var form;

function form_changed (is) {
	is_form_unpublished = 1;
	if(is == undefined) 
		return is_form_changed;

	is_form_changed = is;

	set_save_buttons(is_form_changed);
}

function check_publish () {

	if(is_form_unpublished == 0) {
		return true;
	}

	if( confirm("Menu has changed and not been published. Continue?") ) {
		return true;
	}

	return false;
}

function check_change (wid) {

	form.cancelsubmit.value = wid == undefined ? 0 : 1;

	if(form_changed() == 0) {
		form.cancelsubmit.value = '';
		return true;
	}

	if( confirm("[L]Form has changed and not been saved. Continue?[/L]") ) {
		form.cancelsubmit.value = '';
		return true;
	}

	return false;
}

function set_checked_buttons (enab) {
	if(enab == undefined) 
		enab = 0;
	var dis;
	var vis;
	var weight;
	var f = document.qmenuform;
	if(enab == 0) {
		dis = 1;
		vis = 'Hidden';
		weight = 'normal';
		f.insbutton.value = "[L]Append menu item[/L]";
	}
	else {
		dis = 0;
		vis = 'Visible';
		weight = 'bold';
		f.insbutton.value = "[L]Insert menu item[/L]";
	}
	var singles = [ f.delbutton, f.upbutton, f.downbutton ];
	var buttons = [ singles, f.loadbutton, f.copybutton ];
	var j;
	for ( j = 0; j < buttons.length; j++) {
		var ary = buttons[ j];
		var i;
		for( i = 0; i < ary.length; i++) {
			var el = ary[ i];
			if(el != undefined) {
				el.disabled			= dis;
				el.style.visibility	= vis;
				el.style.fontWeight	= weight;
			}
		}
	}
	return;
}

function set_save_buttons (enab) {
	if(enab == undefined) 
		enab = 0;
	var color;
	var weight;
	if(enab == 0) {
		color = '#666666';
		weight = 'normal';
	}
	else {
		color = '#000000';
		weight = 'bold';
	}
	var f = document.qmenuform;
	var buttons = f.savebutton;
	var i;
	for( i = 0; i < buttons.length; i++) {
		var el = buttons[ i];
		if(el != undefined) {
			el.style.color			= color;
			el.style.fontWeight	= weight;
		}
	}
	return;
}


function checkit(idx) {
	var nam = 'img' + idx;
	var i_el = document.getElementById(nam);
	var l = lines[ idx ];

	if(l != undefined && l[ CHECK] == 1) {
		checkcur = l[ CHECK] = 0;
		i_el.src = empty_img;
		set_checked_buttons(0);
		return void(0);
	}
	var i;
	var uncheck = new Array;
	var j = 0;
	for(i = 1; i < lines.length; i++)  {
		if(lines[ i][ CHECK] == 1) {
			uncheck[ j] = i;
			j++;
		}
	}

	for(i = 0; i < uncheck.length; i++) {
		var n = uncheck[ i];
		lines[ n][ CHECK] = 0;
		var el = document.getElementById('img' + n);
		el.src = empty_img;
	}

	checkcur = idx;
	lines[ idx ][ CHECK] = 1;
	i_el.src = full_img;
	set_checked_buttons(1);
	// alert("checkcur=" + checkcur);
	return void(0);
}

function escapeParams (parms) {
	// alert("parms=" + parms);
	parms = parms.replace(/[\r\n]+/g, "\n");
	parms = parms.replace(/^\s+/, "");
	parms = parms.replace(/\s+$/, "");
	parms = parms.replace(/=/g, "-_EQUAL_X_-");
	parms = parms.replace(/\n/g, "-_NEWLINE_X_-");
	parms = escape(parms);
	parms = parms.replace(/-_NEWLINE_X_-/g, '[either]@@UrlJoiner@@[or]&[/either]');
	parms = parms.replace(/-_EQUAL_X_-/g, '=');
	// alert("parms=" + parms);
	return parms;
}

function unescapeParams (parms) {
	// alert("parms=" + parms);
	parms = parms.replace(/=/g, "-_EQUAL_X_-");
	parms = parms.replace(/[either]@@UrlJoiner@@[or]&[/either]/g, "-_NEWLINE_X_-");
	parms = unescape(parms);
	parms = parms.replace(/-_NEWLINE_X_-/g, "\n");
	parms = parms.replace(/-_EQUAL_X_-/g, '=');
	// alert("parms=" + parms);
	return parms;
}

var page_rep = '';
var params_rep = '';
var name_rep = '';
var showlevel = 1;
var toggle_bg = 'FFFFFF';
var collapseit;
var explodeit;

function toggleShowlevel () {
	if(showlevel != 1) {
		showlevel = 1;
	}
	else {
		showlevel = 0;
	}

	if(tree_mode == 1) {
		for(var i = 1; i < lines.length; i++)
			rewrite_tree(i);
	}
	else {
		showlevel = 0;
	}
	form.showlevel.checked = showlevel;
}

function reset_collapse () {
		if(explodeit != undefined) 
			explodeit.checked = false;
		if(collapseit != undefined) 
			collapseit.checked = false;
}

function toggleItem (idx, formel, explode) {
	toggle = new Array;
	toggle_bg = 'FFFFFF';
	reset_collapse();

	if(formel != undefined) {
		if(explode == 1) 
			explodeit = formel;
		else
			collapseit = formel;

		formel.checked = true;
		idx = 1;
		if(explode != 1)
			explode = 0;
		for(var i = 1; i < lines.length; i++) {
			lines[ i ][0] = explode;
		}
	}
	else {
		if(lines[ idx ] == undefined)
			return;
		if(lines[ idx ][0] == 0)
			lines[ idx ][0] = 1;
		else 
			lines[ idx ][0] = 0;
	}
	for(var i = 1; i < lines.length; i++)
		rewrite_tree(i, 1);
}

function toggleName (form,val) {
	if(val != undefined) {
		val = val.replace(/\s+$/, '');
		if (val == '') {
			form.label.checked = 1;
		}
		else {
			form.label.checked = 0;
		}
		return;
	}

	if(form.label.checked) {
		page_rep = form.page.value;
		params_rep = form.params.value;
		form.page.value = '';
		form.params.value = '';
	}
	else {
		form.page.value = page_rep;
		form.params.value = params_rep;
	}
	set_save_buttons(form_changed);
	return;
}

function toggleBreak (form,val) {
	if(val != undefined) {
		val = val.replace(/\s+$/, '');
		if (val == '') {
			form.breakline.checked = 1;
		}
		else {
			form.breakline.checked = 0;
		}
		return;
	}
		
	if(form.breakline.checked) {
		form.label.checked = 0;
		toggleName(form);
		form.label.checked = 1;
		toggleName(form);
		name_rep = form.name.value;
		form.name.value = '';
	}
	else {
		form.name.value = name_rep;
	}
	set_save_buttons(form_changed);
	return;
}

function ext_name (str) {
	var pos = str.indexOf('_') + 1;
	if(pos < 1) 
		return '';
	str = str.substr(pos);
	return str;
}

function show_title (idx, msg) {
	if(document.qmenuform.show_info == undefined ||
		document.qmenuform.show_info.checked != true)
		return;
	var el = document.getElementById('titlebox');
	if(el == undefined) 
		return;
	if(msg == undefined) 
		msg = ltitle[ idx ];
	if(idx == 0 || msg.length == 0) {
		el.style.visibility = 'Hidden';
		el.style.display = 'none';
	}
	else {
		el.innerHTML = msg;
		el.style.visibility = 'Visible';
		el.style.display = 'block';
	}
}

function set_mode (mode) {
	if(mode == 'toggle') {
		if(tree_mode == 0) {
			mode = 'tree';
		}
		else {
			mode = 'simple';
		}
	}
	var f = document.qmenuform;
	var el = f.treebutton;
	var ch = f.qmenu_tree;
	var cht = f.qmenu_write_tree;
	var tel = document.getElementById('treebox');
// alert("change mode, el=" + el);
	if(mode == 'tree') {
		tree_mode = 1;
		toggleItem(0, form.collapse, 0);
		lines[1][ MSORT] = 0;
		el.value = "[L]Set simple mode[/L]";
		ch.checked = 1;
		cht.checked = 1;
		tel.style.visibility = 'Visible';
		tel.style.display = 'block';
	}
	else {
		toggleItem(0, form.explode, 1);
		tree_mode = 0;
		lines[1][ MSORT] = 'x';
		el.value = "[L]Set tree mode[/L]";
		ch.checked = 0;
		cht.checked = 0;
		tel.style.visibility = 'Hidden';
		tel.style.display = 'none';
	}
	var i;
	for(i = 1; i < lines.length; i++) {
		rewrite(i);
	}
	return;
}

function rewrite_tree (idx, tog) {
	var out = '';

	var l = lines[ idx ];
	var next = lines[idx + 1];

	var children = 0;

		
	if(l != undefined && idx < lines.length) {
		// out =	idx + 
		if(next != undefined && next[ MSORT] > l[ MSORT] ) 
			children = 1;
		out = ' <a href="javascript:checkit(' + idx + ');void(0)"><img ';
		if(l[ CHECK] == 1) {
			out = out + 'src="' + full_img + '" ';
		}
		else {
			out = out + 'src="' + empty_img + '" ';
		}

		var grp = l[ MSORT] + '';
// alert("rewrite grp=" + grp);
		if(! grp.match(/^\d+$/) ) {
			l[ MSORT] = 0;
		}

		toggle[ l[ MSORT] ] = l[0];

		out = out + 'border=0 align=absbottom ' +
				'id="img' + idx + '"></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'up');void(0)" +
				'"><img src="' + up_img + '"' + up_title + ' border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'down');void(0)" +
				'"><img src="' + down_img + '"' + down_title + ' border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'left');void(0)" +
				'"><img src="' + left_img + '"' + left_title + ' border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'right');void(0)" +
				'"><img src="' + right_img + '"' + right_title + ' border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:loadForm(' + idx + ");void(0)" +
				'"><img src="' + forward_img + '"' + forward_title + ' border=0 align=absbottom></A>' + "\n";
		for(i = 0; i < l[ MSORT]; i++)
			out = out + '&nbsp;&nbsp;&nbsp;'; 
		if(children == 1) {
			var img;
			if( l[0] != 0 ) {
				img = minus_img;
				htitle = minus_title;
			}
			else {
				img = plus_img;
				htitle = plus_title;
			}
			out = out + 
				'<a href="javascript:toggleItem(' + idx + ");void(0)" +
				'"' + htitle + '><img border=0 src="' + img + '"></A>' + "\n";
		}
		else {
			out += '<img border=0 height=16 width=16 src="' + leaf_img + '">';
		}
		if(showlevel == 1 && l[ MSORT] > 0) {
			out = out + l[ MSORT] + '&nbsp;'
		}

		var nme = l[ NAME];
		// force text variable
		nme = nme + '';
		if(nme != undefined) {
			nme = nme.replace(/</g, '&lt;');
		}
		if(l[ PAGE]) {
			var i;
			out = out + '<a href="javascript:loadForm(' +
					idx + ');void(0)"' +
					' onDblClick="checkit(' + idx + ')"' +
					' title="' + l[ PAGE];
			if(l[ FORM])
				out = out + '?' + l[ FORM];
			if(l[ DESCRIPTION])
				out = out + " : " + l[ DESCRIPTION];
			out = out + '">' + nme + '</a>';
		}
		else {
			out = out + '<b>' + nme + '</b>';
		}

		if(l[ MSG]) {
			out = out + ' <i class=cmessage style="font-size: 8pt;">(' + l[ MSG] + ')</i>';
		}
	}

	var el = document.getElementById('box' + idx);
// alert("rewriting, el=" + el);
	
	if(tog == 1) {
		for(var n = 0; n < l[ MSORT]; n++) {
			if(toggle[ n] == 0)
				out = '';
		}
		if(out != '') {
			el.style.background = '#' + toggle_bg;
			el.style.display = 'block';
			if(toggle_bg == 'FFFFFF')
				toggle_bg = 'EEEEEE';
			else 
				toggle_bg = 'FFFFFF';
		}
		else {
			el.style.background = '#FFFFFF';
			el.style.display = 'none';
		}
	}
	el.innerHTML = out;

	if(l != undefined && l[ CHECK] == 1)
		checkcur = idx;
	// alert("idx=" + idx + ", writing " + out);
	if(lines.length > 25) 
		document.getElementById('scrollbox').style.overflow = 'scroll';
	if(lines.length < 25) 
		document.getElementById('scrollbox').style.overflow = 'visible';
	return;
}

function rewrite (idx) {
	if(tree_mode == 1)
		return rewrite_tree(idx);

	var out = '';

	var l = lines[ idx ];
		
	if(l != undefined && idx < lines.length) {
		// out =	idx + 
		out = ' <a href="javascript:checkit(' + idx + ');void(0)"><img ';
		if(l[ CHECK] == 1) {
			out = out + 'src="' + full_img + '" ';
		}
		else {
			out = out + 'src="' + empty_img + '" ';
		}

		var linktitle = '';
		var lzero = lines[0];
		for(var k = 1; k < lzero.length; k++) {
			var lstring = l[ k] + '';
			if(lstring.length > 0)
				linktitle = linktitle + '<b>' + lzero[ k] + ':</b> ' + lstring + "<br>";
		}
		out = out + 'border=0 align=absbottom ' +
				'id="img' + idx + '"></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'up');void(0)" +
				'"><img src="' + up_img + '" border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:motion(' + idx + ", 'down');void(0)" +
				'"><img src="' + down_img + '" border=0 align=absbottom></A>' + "\n" +
				'<a href="javascript:loadForm(' + idx + ");void(0)" +
				'"><img src="' + transfer_img + '" border=0 align=absbottom></A>' + "\n";

		var nme = l[ NAME];
		if(nme.length > 30) {
			nme=nme.substr(0,27) + '...';
		}
		if(l[ PAGE]) {
			out = out + '&nbsp;&nbsp;&nbsp;<a href="javascript:loadForm(' +
					idx + ');void(0)"' +
					' onDblClick="checkit(' + idx + ')"' +
					' onMouseOver="show_title(' + idx + ')"' +
					' onMouseOut="show_title(0)"' +
					' title="' + l[ PAGE];
			if(l[ FORM])
				out = out + '?' + l[ FORM];
			out = out + '">' + nme + '</a>';
		}
		else {
			out = out + '<span style="font-weight: bold"' +
					' onMouseOver="show_title(' + idx + ')"' +
					' onMouseOut="show_title(0)"' + '>' +
					nme + '</span>';
		}

		if(l[ MSG]) {
			out = out + ' <i class=cmessage style="font-size: 8pt;">(' + l[ MSG] + ')</i>';
		}

		// Set box title array
		ltitle[ idx ] = linktitle.replace(/\r/g, '<br>');
	}

	var el = document.getElementById('box' + idx);
// alert("rewriting idx=" + idx + ", el=" + el);
	el.innerHTML = out;
	if(l != undefined && l[ CHECK] == 1)
		checkcur = idx;
	// alert("idx=" + idx + ", writing " + out);
	if(lines.length > 25) 
		document.getElementById('scrollbox').style.overflow = 'scroll';
	if(lines.length < 25) 
		document.getElementById('scrollbox').style.overflow = 'visible';
	return;
}

function delRow (idx) {

	if( ! check_change() )
		return;

	zeroForm;

	if(idx == undefined || idx < 1) {
		idx = checkcur;
		if(idx > 0)
			checkit(idx);
	}
	if(idx == undefined || idx < 1) {
		alert("No row selected!");
		return;
	}

	var l = lines[ idx ];
	if(l == undefined) {
		alert("deleting non-existent row!");
		return;
	}

	var needs_confirm = l[ PAGE].length || l[ FORM].length

	var i;
	for(i = 3; i < 8; i++) {
		if(l[ i] != undefined && l[ i].length) {
			needs_confirm = 1;
			break;
		}
	}
		
	if(needs_confirm && ! confirm("Delete row " + idx + ", '" + lines[ idx ][ NAME] + "'?") )
		return;

	var len  = lines.length;
	var last = len - 2;

	if(tree_mode == 1) {
		var d = lines[idx + 1];
		if(l[ MSORT] == 0 && d != undefined && d[ MSORT] > 0) {
			motion(idx + 1, 'left');
		}
		else {
			var save = no_alert;
			no_alert = 1;
			motion(idx, 'left');
			no_alert = save;
		}
	}

	for( i = idx; i <= last; i++) {
		lines[ i] = lines[i+1];
		rewrite(i);
	}
	len--;
	lines.length   = len;
	rewrite(len);
	for(i = idx; i <= len; i++) 
		rewrite(i);
	return;
}

function insRow (idx) {

	if( ! check_change() )
		return;

	if(idx == undefined || idx < 1) {
		idx = checkcur;
		if (idx > 0)
			checkit(idx);
	}

	if(idx == undefined || idx < 1) {
		idx = lines.length;
	}

	lines.length = lines.length + 1;
	var last = lines.length - 1;
	
	if(lines[ idx ] != undefined) {
		var penult = last - 1;
		var i;
		for( i = penult; i >= idx; i--) {
			lines[i + 1] = lines[ i];
			rewrite(i + 1);
		}
	}

	lines[ idx ] = new Array;
	for (i = 0; i < CHECK; i++)
		lines[ idx ][ i] = '';
	lines[ idx ][ MSG] = '[L]NEW[/L]';

	if(tree_mode == 1) {
		if(lines[idx - 1] != undefined) {
			lines[ idx ][ MSORT] = lines[idx-1][ MSORT];
		}
		else {
			lines[ idx ][ MSORT] = 0;
		}
	}

	rewrite(idx);

	var ch = [	form.page.value,
				form.params.value,
				form.description.value,
				form.extended.value];
	var something = 0;
	var i;
	for(i = 0; i < ch.length; i++) {
		if(ch[ i] != undefined && ch[ i].length > 0) {
			something = 1;
			break;
		}
	}

	form.lineidx.value = idx;
	if(something > 0 && confirm("Start item out with values from form?")) {
		saveForm(idx);
	}
	return;
}

function loadForm (idx, msg, zeromsg) {
	if( ! check_change() )
		return;

	if(idx == undefined || idx <= 0) {
		idx = checkcur;
		if (idx <= 0) return;
		checkit(idx);
	}

	if(msg == undefined)
		msg = '[L]loaded[/L]'; 
						
	if(zeromsg == undefined)
		zeromsg = '[L]loaded[/L]';

	var l = lines[ idx ];
	// alert("idx=" + idx + "\nl=" + l + "\nform=" + form);

	form.name.value      = name_rep   = l[ NAME];
	form.page.value      = page_rep   = l[ PAGE];
	form.params.value    = params_rep = unescapeParams(l[ FORM]);
	form.description.value            = l[ DESCRIPTION];
	form.mgroup.value                 = l[ MGROUP];

	for(var x = 0; x < extra.length; x++) {
		var el;
		var en = extra[ x];
		var un = en.toUpperCase();
		var eidx;
		eval('eidx = ' + un);
		eval ('el = form.ext_' + en );
//			if( x < 2) {
// alert('loading extra form value ' + en + '(' + un + '), eidx=' + eidx + ', value=' + l[ eidx]);
//			}
		if(el == undefined) {
			alert('bad extra form element: ' + en);
			continue;
		}
		if(el.type == 'select') {
			for(var j = 0; j < el.length; j++) {
				if(el.options[ j].value == l[ eidx]) {
					el.selectedIndex = j;
					break;
				}
			}
		}
		else {
			el.value = l[ eidx];
		}
	}

	if(INACTIVE != undefined) {
		form.inactive.disabled = 0;
		form.inactive.checked = l[ INACTIVE] ? 1 : 0;
	}
	else {
		form.inactive.disabled = 1;
	}

	if(form.page.value == '') {
		form.label.checked = 1;
	}
	else {
		form.label.checked = 0;
	}
	if(form.name.value == '') {
		form.breakline.checked = 1;
	}
	else {
		form.breakline.checked = 0;
	}
	form.lineidx.value = idx;

	var j;
	for(j = 0; j < lines.length; j++) {
		if(lines[ j] != undefined && lines[ j][ MSG] == zeromsg) {
			lines[ j][ MSG] = '';
			rewrite(j);
		}
	}
	l[ MSG] = msg;
	rewrite(idx);
	form_changed(0);
	mvpan_selectTab(0);
	return;
}

function zeroForm (form) {
	if(form == undefined) {
		form = document.qmenuform;
	}
	form.page.value = '';
	form.params.value = '';
	form.name.value = '';
	form.description.value = '';
	form.mgroup.value = '';
	if(EXTENDED != undefined)
		form.extended.value = '';

	form.inactive.checked = 0;
	form.breakline.checked = 0;
	form.label.checked = 0;
	form.lineidx.value = 0;

	for(var x = 0; x < extra.length; x++) {
		var el;
		var en = extra[ x ];
		var un = en.toUpper;
		eval ('el = form.ext_' + en );

		if(el.type == 'select') {
			el.selectedIndex = undefined;
		}
		else {
			el.value = '';
		}
	}


	form_changed(0);
	mvpan_selectTab(0);
	return;
}

function boxMsg (idx, msg) {
	
}

function saveForm (idx, msg, zeromsg) {

	if(idx == undefined || idx < 1)
		idx = form.lineidx.value;

	if(idx <= 0) {
		alert("Improper line index " + idx);
		return;
	}
	var l = lines[ idx ];

	if(msg == undefined)
		msg = '[L]saved[/L]';

	if(zeromsg == undefined)
		zeromsg = '[L]saved[/L]';

	// alert("idx=" + idx + "\nl=" + l + "\nform=" + form);

	form.lineidx.value = idx;
	l[ PAGE] = form.page.value;
	l[ FORM] = escapeParams(form.params.value);
	l[ NAME] = form.name.value;
	l[ MGROUP] = form.mgroup.value;

	var ttt = form.description.value;
	ttt = ttt.replace(/\r\n/g, "\r");
	l[ DESCRIPTION] = ttt.replace(/\n/g, "\r");

	for(var x = 0; x < extra.length; x++) {
		var el;
		var en = extra[ x ];
		var un = en.toUpperCase();
		var eidx;
		eval('eidx = ' + un);
		eval('el = form.ext_' + en );

		if(el.type == 'select') {
			var sel = el.options[el.selectedIndex];
			if(sel == defined) {
				l[ eidx ] = sel.value;
			}
			else {
				l[ eidx ] = '';
			}
		}
		else {
			l[ eidx ] = el.value;
		}
	}

	if(INACTIVE != undefined) {
		l[ INACTIVE] = form.inactive.checked ? 1 : 0;
	}

	var j;
	for(j = 0; j < lines.length; j++) {
		if(lines[ j ] != undefined && lines[ j ][ MSG ] == zeromsg) {
			lines[ j ][ MSG ] = '';
			rewrite(j);
		}
	}

	l[ MSG] = msg;
	if(checkcur > 0)
		checkit(checkcur);
	rewrite(idx);
	zeroForm();
	return;
}

function setOutput () {
	var output = new Array;
	var i;
	var linelen = [calc]scalar @menufields[/calc];
	output[0] = "[calc]join "\\t", @menufields [/calc]";
// alert("fields=" + output[0]);
	document.qmenuform.qmenu_text.value = output[0];
	for(i = 1; i < lines.length; i++) {
		var ttt = "" + i;
		while( ttt.length < 3 )
			ttt = '0' + ttt;
		var tl = new Array;
		var j;
		tl[0] = ttt;
		if(tree_mode != 1)
			lines[ i][ MSORT] = 'x' + ttt;
		for( j = 1; j < linelen; j++) {
			tl[ j] = lines[ i][ j];
			if(tl[ j] == undefined) 
				tl[ j] = '';
		}
		if(tl[ DESCRIPTION]) 
			tl[ DESCRIPTION] = tl[ DESCRIPTION].replace(/\r/g, "\\r");
		if(EXTENDED != undefined) 
			tl[ EXTENDED] = tl[ EXTENDED].replace(/\r/g, "\\r");
		output[ i] = tl.join("\t");
	}
	document.qmenuform.qmenu_text.value = output.join("\n") + "\n";
// alert(document.qmenuform.qmenu_text.value);
	return;
}

function canon_lines () {
	for(i = lines.length - 1; i > 0; i--) {
		if(lines[ i] != undefined)
			break;
		lines.length = lines.length - 1;
	}
}

function do_alert (msg) {
	if(no_alert != 1)
		alert(msg);
}

function moveit (idx, motion) {
	var up = idx - 1;
	var dn = idx + 1;

	var dest;

	if (up < 1 && motion == 'up')
		return void(0);
	if (dn > lines.length - 1 && motion == 'down')
		return void(0);

	reset_collapse();

	dest = motion == 'up' ? up : dn;

	var tmp = lines[ dest];
	lines[ dest] = lines[ idx];
	lines[ idx] = tmp;

	rewrite(idx);
	rewrite(dest);

	return;
}

function movetree (idx, motion) {
	var up = idx - 1;
	var dn = idx + 1;

	if(up < 1) {
		alert("Can't move first element in tree.");
		return;
	}

	var end = checkcur;

	if(end < idx)
		end = idx;
	
	var x;
	for(x = idx; x <= end; x++) {
		var l = lines[ x];
		var u = lines[ up];
		var d = lines[ dn];
		u[ MSORT] *= 1;
		l[ MSORT] *= 1;
		if(isNaN(u[ MSORT])) {
			u[ MSORT] = 0;
		}

		if(isNaN(l[ MSORT])) {
			l[ MSORT] = 0;
		}

		if(motion == 'left') {
			if(l[ MSORT] == 0) {
				if(x == idx) {
					do_alert("Already at top level.");
					break;
				}
			}
			else {
				l[ MSORT] -= 1;
			}
			while (x >= end && d != undefined && d[ MSORT] - 1 > l[ MSORT]) {
				d[ MSORT] -= 1;
				rewrite_tree(dn, 1);
				dn++;
				d = lines[ dn];
			}
		}
		else {
			if(l[ MSORT] > u[ MSORT]) {
				if(x == idx) {
					do_alert("Already at farthest right, need parent at same level or higher.");
					break;
				}
			}
			else {
				l[ MSORT] += 1;
			}
		}
		dn++;
		up++;
		rewrite(x);
	}

	return;
}

function search_win () {
		window.name = 'mainwindow[scratch window_name]';
		var url = '[area
						href="admin/search_wizard"
						form=|
							ui_source_form=qmenuform
							ui_source_var=params
						|]';
		url += '&ui_searchblob=' + escape(form.params.value);
		window.open(url, undefined, 'scrollbars,location=no,status=no,toolbar=no,resizable,fullsize=no,width=900,height=700');
		return void(0);
}

function movethem (idx, end, target) {
	var tmp = new Array;
	reset_collapse();

	for (var i = target; i < idx; i++) {
		tmp[tmp.length] = lines[ i];
	}

	var j = target;
	for(var i = idx; i <= end; i++, j++) {
		lines[ j] = lines[ i];
	}
	for (var i = 0; i < tmp.length; i++, j++) {
		lines[ j] = tmp[ i];
	}
	for(var i = 1; i < lines.length; i++) 
		rewrite_tree(i, 1);
}

function motion (idx, motion, fromchecked) {

	if(motion == 'left' || motion == 'right') {
		if(tree_mode != 1) {
			alert("Not in tree mode, can't move " + motion);
			return;
		}

		return movetree(idx, motion);
	}
	if(fromchecked == 1) {
		idx = checkcur;
		if(idx == undefined || idx < 1)
			return;
	}

	var up = idx - 1;
	var dn = idx + 1;

	if( ! check_change() )
		return;

	var dest;

	// alert("checkcur=" + checkcur + "\nidx=" + idx + "\ndest=" + dest);
	if (checkcur != 0 && fromchecked != 1) {
		if(tree_mode == 1) {
// alert('in tree mode move');
			var extant;
			var m;
			var nextpeer;
			var prevpeer;
			var clev = lines[ checkcur][ MSORT];
			if(motion == 'down') {
				
				for(m=checkcur + 1; extant==undefined; m++) {
// alert('in tree mode move, m=' + m + ', nextpeer=' + nextpeer + ', extant=' + extant + ', checkcur=' + checkcur + '');
					if(lines[ m] == undefined) {
						if(nextpeer == undefined)
							return void(0);
						extant = m - 1;
// alert('ready for tree mode move, m=' + m + ', nextpeer=' + nextpeer + ', extant=' + extant + ', checkcur=' + checkcur + '');
					}
					else if(lines[ m][ MSORT] <= clev) {
						if(nextpeer == undefined) {
							nextpeer = m;
						}
						else {
							extant = m -1;
// alert('ready for tree mode move, m=' + m + ', nextpeer=' + nextpeer + ', extant=' + extant + ', checkcur=' + checkcur + '');
						}
					}
				}
				movethem(nextpeer, extant, checkcur);
				return void(0);
			}
			else {
				var m;
				for(m=checkcur + 1; extant==undefined; m++) {
					if(lines[ m] == undefined || lines[ m][ MSORT] == clev) {
// alert('tree move up, extant=' + extant + ', checkcur=' + checkcur + '');
						extant = m - 1;
					}
				}
				for(m=checkcur - 1; prevpeer==undefined; m--) {
					if(lines[ m] == undefined) {
							return void(0);
					}
// alert('in tree mode move, m=' + m + ',  prevpeer=' + prevpeer + ', extant=' + extant + ', checkcur=' + checkcur + '');
					if(lines[ m][ MSORT] == clev) {
						prevpeer = m;
					}
				}
				movethem(checkcur, extant, prevpeer);
				return void(0);
			}
		}
		else {
			dest = checkcur;
			checkit(checkcur);
			if(idx == dest) 
				return void(0);
			if(idx < dest) {
				var k;
				if(motion == 'up') 
					dest--;

				for( k = idx; k < dest; k++) {
					moveit(k, 'down');
				}
			}
			else {
				var k;
				if(motion == 'down') 
					dest++;
				for( k = idx; k > dest; k--) {
					moveit(k, 'up');
				}
			}
			motion = 0;
		}
	}
	else {
		if (up < 1 && motion == 'up')
			return void(0);
		if (dn > lines.length - 1 && motion == 'down')
			return void(0);
		dest = motion == 'up' ? up : dn;
	}

	// alert("checkcur=" + checkcur + "\nidx=" + idx + "\ndest=" + dest);
	if (motion) {
		moveit(idx, motion);
	}

	return void(0);
}

</script>
[/restrict]

[output name="top_of_form"]
<form name=qmenuform action="[process href=@@MV_PAGE@@]" method=POST>
                [form-session-id]
		<input name=mv_action type=hidden value="back">
		<input name=cancelsubmit type=hidden value="">
		<input name=return_page type=hidden value="[cgi return_page]">
		<input name=qmenu_name type=hidden value="[scratch qmenu_name]">
		<input name=qmenu_text type=hidden value="">
[output name=top_buttons]
<span class=s3>
[L]Save to new menu[/L] <input name=qmenu_new type=text size=20 value="[cgi qmenu_new]" class=s3>
		<input type=submit
				style="Visibility: Hidden;"
				disabled=1
				name=junksubmit
				value=".">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<input type=button
				onClick="set_mode('toggle')"
				name=treebutton
				value="[L]Set tree mode[/L]" class=s3>
		<input type=submit name=doit style="font-weight: bold" value="[L]Publish[/L]" onClick="check_change(1) && setOutput()" class=s3>
		&nbsp;&nbsp;&nbsp;
		<input type=submit
				onClick="
					this.form.qmenu_text.value='';
					this.form.qmenu_new.value='';
					this.form.qmenu_name.value='';
					[if cgi return_page]
					this.form.action='[area href='[cgi return_page]']';
					[/if]
					"
				value="[L]Cancel[/L]" class=s3>
</span>
[output name=""]
<table width="100%">
<tr>
	<td>
		<input type=button
				onClick="insRow()"
				name=insbutton
				value="[L]Insert menu item[/L]">
		<input type=button
				name=delbutton
				style="visibility: Hidden;"
				disabled=1
				onClick="delRow()"
				value="[L]Delete menu item[/L]">
		<input type=button
				name=upbutton
				style="visibility: Hidden;"
				disabled=1
				onClick="motion(0,'up',1)"
				value="[L]Up[/L]">
		<input type=button
				name=downbutton
				style="visibility: Hidden;"
				disabled=1
				onClick="motion(0,'down',1)"
				value="[L]Down[/L]">
	</td>
	<td>
		<div id=treebox style="font-size: 10px; display: none">
        <span class="nowrap"><input type=checkbox name=show_info value=1 class=nowrap> [L]Show item info[/L]</span>
		<span class="nowrap"><input type=checkbox name=qmenu_tree value=1 class=nowrap> [L]Tree mode[/L]</span>
		<span class="nowrap"> <input type=checkbox name=qmenu_write_tree value=1 class=nowrap> [L]Write tree to DB[/L]</span>
		<span class="nowrap"> <input type=checkbox name=showlevel value=1 class=nowrap onClick="toggleShowlevel()" CHECKED=1> [L]Show numerical level[/L]</span>
		<span class="nowrap"><input type=checkbox name=collapse value=1 class=nowrap onClick="toggleItem(0,this,0)"> [L]Collapse tree[/L]</span>
		<span class="nowrap"><input type=checkbox name=explode value=1 class=nowrap onClick="toggleItem(0,this,1)"> [L]Explode tree[/L]</span>
		</div>
	</td>
</tr>
</table>
	<div id=titlebox style="
						position: Absolute;
						Top: 300;
						Left: 300;
						border: 2pt gray solid;
						background: #CCCCCC;
						float: right;
						Visibility: Hidden;
						zAxis: 2;
						">
		Test floatbox.
	</div>
<table width="95%">
<tr>
	<td width="40%" valign=top>[set empty][/set]
	<div id=scrollbox style="
						width: 100%;
						height: 800px;
						overflow: auto;
						border: 1pt gray shaded;
						">
[loop head-skip=1 lr=1 list="[scratch qmenu_data]"][list]<div id=box[loop-increment] style="font-size: 11pt; width=300px; [loop-alternate 2]Background: #EEEEEE;[/loop-alternate]"></div>
[/list][no-match][set empty]1[/set][/no-match]
[/loop]
[loop ranges=1 list="[scratch lastfull]..[scratch loopinc]"]<div id=box[loop-code] style="font-size: 11pt; width=300px;">[loop-change 1]
[condition]1[/condition][if scratch empty]
<h3>[L]Create menu from HTML[/L]</h3>
<textarea name=qmenu_html_create rows=20 cols=50
onChange="this.form.qmenu_new.focus()"></textarea>
<br>
<input type=submit name=qmenu_create value="[L]Create New Menu[/L]">
[/if]
[/loop-change 1]</div>
[/loop]
	</div>
	</td>
	<td valign=top>

	<input type=hidden name=lineidx value="0">
	<table width="100%">
	<tr>
	  <td>
[tabbed-display panel-width="500" panel-height="100%" panel-shade=e tab-height=24 tab-width=150]
[tabbed-panel [L]General[/L]]
		<table>
		<tr>
			<td class=clabel>
				[L]Name[/L]
			</td>
			<td class=cdata>
				<input name=name type=text size=30 onChange="form_changed(1);toggleBreak(this.form,this.value); void(0)">
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Page[/L]
			</td class=cdata>
			<td class=cdata>
				<input name=page type=text size=50 onChange="form_changed(1);toggleName(this.form,form.page.value)">
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Form values[/L]<br>
				<input name=ui_searchblob type=hidden value="">
				<input name=ui_source_win type=hidden value="[scratch window_name]">

			<div align=right>
			<input
				style="font-size: smaller; font-weight: bold;"
				type=button
				value="[L]Create search[/L]"
				onClick="this.form.page.value = 'search';form_changed(1);search_win();"
				><br><input
							style="font-size: smaller;"
							type=button onClick="this.form.params.value=''"
							value="[L]Clear search[/L]">
			</div>
			</td>
			<td class=cdata>
				<textarea cols=50 rows=4 name=params onChange="form_changed(1);"></textarea>
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Detailed Description[/L]
			</td>
			<td class=cdata>
				<textarea cols=50 rows=4 name=description onChange="form_changed(1);"></textarea>
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Options[/L]
			</td>
			<td class=cdata>
				<input name=label type=checkbox value=1 onChange="form_changed(1);toggleName(this.form)">[L]Label only[/L]<br>
				<input name=breakline type=checkbox value=1 onChange="form_changed(1);toggleBreak(this.form)">[L]Break line[/L]
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Inactive[/L]
			</td class=cdata>
			<td class=cdata>
			<input name=inactive  type=checkbox value=1 onChange="form_changed(1);">
			</td>
		</tr>
		<tr>
			<td class=clabel>
				[L]Menu Group[/L]
			</td>
			<td class=cdata>
			 <input name=mgroup  type=text onChange="form_changed(1);">
			</td>
		</tr>
		<tr>
			<td colspan=2>
			<input type=button onClick="saveForm()" name=savebutton value="[L]Save menu item[/L]">
			<input type=button onClick="loadForm()" name=loadbutton
						style="visibility: Hidden;"
						value="[L]Load menu item[/L]">
			<input type=button onClick="saveForm(checkcur)" name=copybutton
						style="visibility: Hidden;"
						value="[L]Copy to checked entry[/L]">
			</td>
		</tr>
		</table>
[/tabbed-panel]

[tabbed-panel [L]Advanced[/L]]
		<table>
<script>
		form = document.qmenuform;
		var i ;
		var tm = 1;

		for(i = 1; i < lines.length; i++) {
			if( isNaN(lines[ i][ MSORT] * 1)  ) {
					tm=0;
					break;
			}
		}

		if(lines.length > 1) {
			if(tm == 1) {
				set_mode('tree');
				toggleShowlevel();
				toggleItem(0, form.collapse, 0);
			}
			else {
				set_mode('simple');
			}
		}

		set_checked_buttons();
		set_save_buttons();
		if(INACTIVE == undefined) {
			document.qmenuform.inactive.disabled = 1;
		}
		initialized = 1;
		var reserved = /^(extended|inactive|description|form|mgroup|msort|name|page|code)$/;
		var f = lines[ 0];
		for (i = 0; i < f.length; i++) {
			var fn = f[ i];
			if(fn && ! fn.match(reserved) ) {
				var nn = 'ext_' + fn;
				var un = fn.toUpperCase();
// alert([jsq]i=$i fn=$fn nn=$nn un=$un[/jsq]);
				var eidx;
				eval('eidx = ' + un);
// alert([jsq]i=$i fn=$fn un=$un nn=$nn eidx=$eidx[/jsq]);
				var nidx = extra.length;
				extra.length += 1;
				extra[ nidx] = fn;
				var lab = fn;
				var wid;
				var helptext = help[ i];
				if(helptext == undefined)
					helptext = '';
				if(label[ eidx] != undefined) {
					lab = label[ eidx];
				}
				if(widget[ eidx] != undefined) {
					wid = widget[ eidx];
				}
				else {
					wid = [jsq]<input type=text name="$nn" onChange="form_changed(1);">[/jsq];
				}
				document.write([jsq]
		<tr>
			<td class=clabel onMouseOver="show_title(1, '$helptext')" onMouseOut="show_title(0)">
				$lab
			</td>
			<td class=cdata>
				$wid
			</td>
		</tr>
			[/jsq]);

			}

		}
		
		if(EXTENDED != undefined) {
			document.write([jsq]
		<tr>
			<td class=clabel>
				[L]Extended Parameters (advanced)[/L]
			</td>
			<td class=cdata>
				<textarea cols=50 rows=4 name=extended onChange="form_changed(1);"></textarea>
			</td>
		</tr>
			[/jsq]);
		}

</script>
		<tr>
			<td colspan=2>
			<input type=button onClick="saveForm()" name=savebutton value="[L]Save menu item[/L]">
			<input type=button onClick="loadForm()" name=loadbutton
						style="visibility: Hidden;"
						value="[L]Load menu item[/L]">
			<input type=button onClick="saveForm(checkcur)" name=copybutton
						style="visibility: Hidden;"
						value="[L]Copy to checked entry[/L]">
			</td>
		</tr>
	</table>
[/tabbed-panel]
[/tabbed-display]
		</td>
	</tr>
	</table>
	</td>
</tr>
</table>
[output name="bottom_buttons"]
		<input type=submit name=doit style="font-weight: bold" value="[L]Publish[/L]" onClick="check_change(1) && setOutput()" class=s3>
		&nbsp;&nbsp;&nbsp;
		<input type=submit
				onClick="
					this.form.qmenu_text.value='';
					this.form.qmenu_new.value='';
					this.form.qmenu_name.value='';
					"
				value="[L]Cancel[/L]" class=s3>
[output name="bottom_of_form"]
</form>
[output name=""]

<!-- ----- END REAL STUFF ----- -->
@_UI_STD_FOOTER_@

