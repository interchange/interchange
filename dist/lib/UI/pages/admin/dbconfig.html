[if cgi ui_remember]
	[calc] $CGI->{mv_data_table} = $Values->{mv_data_table}; return [/calc]
[/if]

[if !cgi mv_data_table]
[bounce page="__UI_BASE__/gentable"]
[/if]
[value name=mv_data_table set="[cgi mv_data_table]" hide=1]

[set page_perm]dbconfig[/set]
[set table_perm]1[/set]
[set page_title]Configuration[/set]
[set ui_class]Admin[/set]
[set help_name]genconfig.main[/set]
[set icon_name]admin/icon_config.gif[/set]

@_UI_STD_HEAD_@

<!-- ----- BEGIN REAL STUFF ----- -->

[perl tables="[list-databases] __UI_META_TABLE__"]
	%ignore;
	my @ignore = qw/
			Class
			db_file
			db_file_extended
			db_file_extended
			db_text
			dir
			DSN
			dsn_id
			Exists_handle
			EXTENDED
			file
			_Insert_h
			_Checked_capability
			name
			Object
			Read_only
			type
			Update_handle
		/;
	@ignore{@ignore} = @ignore;

	%typemap = (
		1	=> 'DBM/Memory, default delimiter (TAB)',
		2	=> 'DBM/Memory, LINE delimiter',
		3	=> 'DBM/Memory, %% delimiter',
		4	=> 'DBM/Memory, CSV delimiter',
		5	=> 'DBM/Memory, PIPE delimiter',
		6	=> 'DBM/Memory, TAB delimiter',
		7	=> 'This should never appear (old Msql)',
		8	=> 'DBI/SQL',
		9	=> 'LDAP',
	);

	%str_typemap = (
		1	=> 'DEFAULT',
		2	=> 'LINE',
		3	=> '%%',
		4	=> 'CSV',
		5	=> 'PIPE',
		6	=> 'TAB',
		8	=> 'SQL',
		9	=> 'LDAP',
	);

	@include_dir = ();
	my %seen;

	for(keys %Db) {
		my $fig = $Db{$_}->config('included_from');
		$fig =~ s:(.*)/::;
		my $dir = $1;
		push @include_dir, $dir unless $seen{$dir}++;
	}

	%Hash_ref = (  qw!
							FILTER_FROM   FILTER_FROM
							FILTER_TO     FILTER_TO 
							COLUMN_DEF    COLUMN_DEF
							FIELD_ALIAS   FIELD_ALIAS
							NUMERIC       NUMERIC
							WRITE_CATALOG WRITE_CATALOG
					! );

	%Ary_ref = (   qw!
							NAME         NAME
							BINARY       BINARY 
							POSTCREATE   POSTCREATE 
					! );

	%Misc_set = (
		GUESS_NUMERIC => '=No numeric guess, 1=Guess numeric fields',
		EXCEL => '=No Excel correction, 1=Correct for Excel peculiarities',
		HOT   => '=Normal open, 1=Keep table always connected',
		CONTINUE   => q{=No extra line processing,
						DITTO="Ditto" line continuation,
						UNIX=Unix-style \ continuation,
						NOTES=Lotus notes (only for LINE delimiter)},
	);

	%Misc_set_sql = (
		LONGTRUNCOK => "1=Silently truncate too-long values, 0=Don't truncate",
	);


	%Adv_set_sql = (
		CHOPBLANKS => "1=Strip trailing white space from fixed-length text, 0=Don't strip (warning: dangerous)",
		HAS_LIMIT  => "0=No LIMIT available, 1=has LIMIT to limit rows",
		AUTOCOMMIT => "=Honor default AutoCommit setting, 0=No AutoCommit, 1=Set AutoCommit",
		PRINTERROR => "=Honor default PrintError setting, 0=No PrintError, 1=Set PrintError",
		RAISEERROR => "=Honor default RaiseError setting, 0=No RaiseError, 1=Set RaiseError",
	);

	@Adv_set_sql_text = qw(
							ALTER_ADD
							ALTER_CHANGE
							ALTER_DELETE
						);

	LOCAL1: {
		my @k = keys %str_typemap;
		for (@keys) {
			$str_typemap{$str_typemap{$_}} = $_;
		}
	}


[/perl]

[if cgi mv_dbconf]
[perl]
	$Dref = {};
	my @keys = grep /^mv_dbconf_/, keys %$CGI;
	my $table = $CGI->{mv_data_table};
	my $string = '';
	#$string = join "\n", 'KEYS', @keys, "";
	for(@keys) {
		my $key = $_;
		$key =~ s/^mv_dbconf_//;
		#$string .= "KEY: $key -- $_\n";
		$Dref->{$key} = $CGI->{$_};
	}

	sub tout {
		my ($param, $data, $prefix) = @_;
		$prefix = '' unless $prefix;
		if($data =~ /\n/) {
			$data = "<<_EOD\n$data\n_EOD\n";
		}
		return sprintf("${prefix}Database %-11s %-15s %s\n", $table, $param, $data);
	}

	$string .= tout($Dref->{file}, $str_typemap{ $Dref->{type} } || $Dref->{type});

	if($Dref->{DSN_default}) {
		$string .= tout('DSN', "__SQL" . 'DSN' . "__");
	}
	else {
		$string .= tout('DSN', $Dref->{DSN});
	}

	if($Dref->{USER_default}) {
		$string .= "#ifdef SQLPASS\n";
		for (qw/USER PASS/) {
			$string .= tout($_,  "__SQL" . $_ . "__");
		}
		$string .= "#endif\n";
	}
	else {
		for (qw/USER PASS/) {
			$string .= tout($_, $Dref->{$_}) if length $Dref->{$_};
		}
	}

	for (keys %Misc_set, keys %Misc_set_sql,) {
		$string .= tout($_, $Dref->{$_}) if length $Dref->{$_};
	}

	for (keys %Adv_set, keys %Adv_set_sql, @Adv_set_sql_text) {
		$string .= tout($_, $Dref->{$_}, '#') if length $Dref->{$_};
	}

	if ($Dref->{CREATE_SQL} =~ /\S/) {
		$Dref->{CREATE_SQL} =~ s/\s*;\s*$//;
		$string .= tout('CREATE_SQL', $Dref->{CREATE_SQL});
	}

	if($Dref->{COLUMN_DEF_type}) {
		my %def;
		for( qw/name type length notnull key default/) {
			$def{$_} = [ split /\0/, $Dref->{"COLUMN_DEF_$_"} ];
		}
		my $count = scalar( @{$def{name}} );
		for(my $i = 0; $i < $count; $i++) {
			my $cdef;
			last if ! ($cdef = $def{name}[$i]);
			next if ! $def{type}[$i];
			$cdef = qq{"$cdef=};
			$cdef .= $def{type}[$i];
			$cdef .= qq{($def{length}[$i])} if $def{length}[$i] =~ /\S/;
			$cdef .= qq{ NOT NULL} if $def{notnull}[$i];
			$cdef .= qq{ PRIMARY KEY} if $def{key}[$i];
			$cdef .= qq{ DEFAULT $def{default}[$i]} if $def{default}[$i] =~ /\S/;
			$cdef .= qq{"};
			$string .= tout('COLUMN_DEF', $cdef);
		}
	}

	if($Dref->{POSTCREATE}) {
		my @lines = grep /\S/, split /;/, $Dref->{POSTCREATE};
		for(@lines) {
			s/^\s+//;
			s/\s+$//;
			$string .= tout('POSTCREATE', $_);
		}
	}
	return "<XMP>$string</XMP>";
[/perl]
[/if]

<center>
<FORM METHOD=POST ACTION="[area @@MV_PAGE@@]">
<table __UI_T_PROPERTIES__>

<tr><td align=left bgcolor=__UI_C_INTBLOCK__>
<TABLE border=0>
<TR>
  <TD BGCOLOR=__UI_C_TOPBLOCKBAR__ COLSPAN=3><img src="@_UI_IMG_@admin/bg.gif" width=__UI_MAIN_WIDTH__ height=1><CENTER>Database configuration</CENTER></TD>
</TR>

<TR>
  <TD COLSPAN=3><input type=submit name=mv_dbconf VALUE="Save"></TD>
</TR>

<TR>
	<TD>&nbsp; &nbsp;</TD>
	<TD>

[comment] Prevent Safe object creation problems [/comment]
[seti have_dbi][version extended=1 modtest='DBI'][/seti]
[seti have_ldap][version extended=1 modtest='Net::LDAP'][/seti]
[seti dbi_info][version extended=1 db=1][/seti]

[perl]
	my @out;
	# Some variables are initialized in the first perl area above
	my $mdb = $Db{__UI_META_TABLE__};

	my $dbi_info = $Scratch->{dbi_info};
	$dbi_info =~ m/.*available drivers:.*?<BLOCKQUOTE>(.*?)<.BLOCKQUOTE>/i;
	my @dbi_drivers = split /\n/, $1;

	my $new;
	my $ref;
	my $tname = $CGI->{mv_data_table};

	$ref = $Config->{Database}{$tname};

	if(! $ref) {
		$new = 1;
		$ref = {};
	}

	my $tinfo = '';
	if($mdb and $mdb->record_exists($tname) ) {
		$tinfo = $mdb->field($tname, 'label');
		if($tinfo) {
			$tinfo = "<br>($tinfo)";
		}
	}

	my $class = $ref->{Class};
	my $file  = $ref->{file};
	my $dir   = $ref->{DIR} || $Config->{ProductDir};

	my $dfile = ($class eq 'DBI' ? $ref->{db_file_extended} : $ref->{db_file});

	$dfile =~ s:^$dir/::o;
	my $text_type  = $typemap{$ref->{type}};
	$text_type .= " DSN=$ref->{DSN}" if $ref->{DSN};

	my $dfn   = $dfile;

	my $current_sql;
	my $use_sql;
	my $base_sql;
	my $pfile = $Config->{ProductFiles}[0];
	if($Db{$pfile} and $Db{$pfile}->config('type') == 8) {
		$base_sql = $pfile;
	}


	if(! $new) {

		$current_sql = 1 if $ref->{type} == 8;

		my $fn = "$dir/$file";
		$file .= "<BR><TT>mod date:   " . $Tag->file_info( { name => $fn, date => 1 } );
		$file .= "<BR>file size: " . $Tag->file_info( { name => $fn, size => 1 } );
		$file .= "</TT>";
		$dfile .= "<BR><B>(not significant for DBI types)</b>" if $class eq 'DBI';
		$dfile .= "<BR><TT>mod date:   " . $Tag->file_info( { name => $dfn, date => 1 } );
		$dfile .= "<BR>file size: " . $Tag->file_info( { name => $dfn, size => 1 } );
		$dfile .= "</TT>";
		my $obj   = $ref->{Object};

		push @out, <<EOF;
<TR>
<TH VALIGN=TOP ALIGN=RIGHT width="15%">
Current
</TH>
<td VALIGN=TOP>
	<TABLE border=1 width="100%">
	<tr>
		<th valign=top align=left>Type</th>
		<td>$text_type</td>
	</tr>
	<tr>
		<th valign=top align=left width="30%">Class</th>
		<td>$class</td>
	</tr>
	<tr>
		<th valign=top align=left width="30%">Directory</th>
		<td>$dir</td>
	</tr>
	<tr>
		<th valign=top align=left width="30%">Text File</th>
		<td>$file</td>
	</tr>
	<tr>
		<th valign=top align=left width="30%">DB File</th>
		<td>$dfile</td>
	</tr>
	</table>
</TD>
</TR>

<TR>
  <TD BGCOLOR=__UI_C_TOPBLOCKBAR__ COLSPAN=3><img src="@_UI_IMG_@admin/bg.gif" width=__UI_MAIN_WIDTH__ height=1></TD>
</TR>
EOF
	}

	$use_sql = 1 if $current_sql or ($new and $base_sql);

	push @out, <<EOF;
<TR>
<TH VALIGN=TOP ALIGN=RIGHT width="15%">
Change Settings
</TH>
<td VALIGN=TOP>
	<TABLE border=1 width="100%">

EOF

	my ($wid, $wid_opt);

	# Don't allow change of table name....
	if($new) {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Table name</th>
		<td><INPUT TYPE=text NAME=mv_data_table
				onChange="
					this.form.mv_dbconf_file.value =
						this.form.mv_data_table.value + '.txt'
						"
				VALUE=""></td>
	</tr>
EOF
	}
	else {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Table name</th>
		<td><INPUT TYPE=hidden NAME=mv_data_table VALUE="$tname"><INPUT TYPE=hidden NAME=mv_dbconf_file VALUE="$ref->{file}">$tname</td>
	</tr>
EOF
	}

	# Allow upload of new file only
	if($new) {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>File name</th>
		<td><INPUT TYPE=text NAME=mv_dbconf_file VALUE=""></td>
	</tr>
	<tr>
		<th valign=top align=left>Upload file</th>
		<td><INPUT TYPE=file NAME=mv_dbconf_upload_file VALUE=""></td>
	</tr>
EOF
	}

	$wid_opts = '1=DBM/Memory';
	$wid_opts .= ", 8=SQL" if $Scratch->{have_dbi};
	$wid_opts .= ", 9=LDAP" if $Scratch->{have_ldap};
	$wid = $Tag->widget( { 
								type => 'select',
								default => $ref->{type},
								passed => $wid_opts,
								name => 'mv_dbconf_type',
							} );

	push @out, <<EOF;
	<tr>
		<th valign=top align=left>Table type</th>
		<td>$wid</td>
	</tr>
EOF

	$wid = $Tag->widget( { 
								type => 'select',
								default => $ref->{delimiter},
								passed => '=Auto-detect, TAB, PIPE, CSV, LINE, %%',
								name => 'mv_dbconf_DELIMITER',
							} );

	push @out, <<EOF;
	<tr>
		<th valign=top align=left>Delimiter type</th>
		<td>$wid</td>
	</tr>
EOF

	my $def_DSN  = $ref->{DSN}  eq $Variable->{SQLDSN}  ? 'CHECKED' : '';
	my $def_USER = $ref->{USER} eq $Variable->{SQLUSER} ? 'CHECKED' : '';
	my $def_PASS = $ref->{PASS} eq $Variable->{SQLPASS} ? 'CHECKED' : '';
	push @out, <<EOF if $use_sql;
	<tr>
		<th valign=top align=left>DSN</th>
		<td><INPUT SIZE=40 NAME=mv_dbconf_DSN VALUE="$ref->{DSN}">
			<INPUT TYPE=checkbox NAME=mv_dbconf_DSN_default $def_DSN> use default
		</td>
	</tr>
	<tr>
		<th valign=top align=left>USER</th>
		<td><INPUT SIZE=40 NAME=mv_dbconf_USER VALUE="$ref->{USER}">
			<INPUT TYPE=checkbox NAME=mv_dbconf_USER_default $def_USER> use default
		</td>
	</tr>
	<tr>
		<th valign=top align=left>PASS</th>
		<td><INPUT SIZE=40 NAME=mv_dbconf_PASS VALUE="$ref->{PASS}">
			<INPUT TYPE=checkbox NAME=mv_dbconf_PASS_default $def_PASS> use default
		</td>
	</tr>
EOF

	if($ref->{included_from}) {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Configuration file</th>
		<td><INPUT TYPE=hidden NAME="mv_dbconf_included_from" value="$ref->{included_from}">$ref->{included_from}</td>
	</tr>
EOF
	}
	else {
		$wid_opts = join ", ", @include_dir;
		$wid = $Tag->widget( { 
								type => 'select',
								passed => $wid_opts,
								name => 'mv_dbconf_included_from',
							} );

		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Configuration directory</th>
		<td>$wid</td>
	</tr>
EOF
	}

	my $def_type = $ref->{DEFAULT_TYPE} || 'char(128)';
	if($current_sql or ($new and $base_sql)) {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Default type</th>
		<td><INPUT TYPE=text NAME=mv_dbconf_DEFAULT_TYPE value="$def_type"></td>
	</tr>
EOF
	}

ROWINFO: {

	my $fdbh;
	if($current_sql) {
		$fdbh = $Sql{$tname};
	}
	elsif ($new and $base_sql) {
		$fdbh = $Sql{$base_sql};
	}

	last ROWINFO unless $fdbh and $fdbh->can('type_info_all');

	my $type_info = $fdbh->type_info_all();

	last ROWINFO unless $type_info and $ref->{NAME};

	my @types;

	for(my $i = 1; $i < @{$type_info}; $i++) {
		my $one = $type_info->[$i];
		my $type = "$one->[0]";
		#$type .= "$one->[0] - $one->[12]";
		#$type .= " (maxlen $one->[2])" if $one->[2] > 0;
		push @types, $type;
	}

	$wid_opts = join ",", "=default $def_type", @types;


	my $sth;
	my @names = @{$ref->{NAME}};
	my @ftype;
	my @itype;

	unless ($new) {
		my $q = "select * from $tname";
		$q .= ' LIMIT 1' if $ref->{HAS_LIMIT};
		my $sth = $fdbh->prepare($q);
		$sth->execute();
		@names = @{$sth->{NAME}};
		@ftype = @{$sth->{TYPE}};
		for (my $i = 0; $i < scalar @ftype; $i++) {
			$itype[$i] = $type_info->[ $ftype[$i] ];
		}
		undef $sth;
	}
	undef $fdbh;


	push @out, <<EOF;
	<tr>
		<th valign=top align=left>Field configuration</th>
		<td><table>
EOF

	for(my $i = 0; $i <= scalar @names; $i++) {
		my $clen = '';
		my $rname = $names[$i];
		if(!$rname) {
			$rname = "(add)<BR><INPUT SIZE=16 NAME=mv_dbconf_COLUMN_DEF_name>";
		}
		my $pkey = $ref->{KEY_INDEX} == $i ? 'SELECTED' : '';
		my $notnull;
		my $fdefault;
		my $tinfo = {};
		if($ref->{COLUMN_DEF}{$rname}) {
			my $def = $ref->{COLUMN_DEF}{$rname};

			$def =~ /  ^\s*
						([^\s(]+)\s*
						(?:
							\(
							   ([^)]+
							)
							\)
						)?/x;

			my $ctype = $1;
			$clen  = $2 || '';
			$ctype = lc($ctype) if $itype[$i] =~ /[a-z]/;
			$tinfo->{TYPE_NAME} = $ctype || $itype[$i];
			$def =~ /\bNOT\s+NULL\b/i and $notnull = 'SELECTED';
			($def =~ /\bdefault\s+'(.*?)'/i and $fdefault = $1)
				or
			($def =~ /\bdefault\s+(\S+)($|\s)/i and $fdefault = $1);
		}

		$wid = $Tag->widget( {
						type => 'select',
						passed => $wid_opts,
						default => $tinfo->{TYPE_NAME},
						name => 'mv_dbconf_COLUMN_DEF_type',
						} );
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>$rname</th>
		<td>
			<table border=1>
			<tr>
				<td><small><b>type</td>
				<td><small><b>length</td>
				<td><small><b>default (if any)</td>
			</tr>
			<tr>
				<td><small>$wid<INPUT TYPE=hidden NAME=mv_dbconf_COLUMN_DEF_name VALUE="$rname"></td>

				<td><small><INPUT SIZE=6 TYPE=text NAME="mv_dbconf_COLUMN_DEF_length" VALUE="$clen"></td>
				<td><small><INPUT SIZE=8 NAME=mv_dbconf_COLUMN_DEF_default VALUE="$fdefault"></td>
			</tr>
			<tr>
				<td><small><b>null status</td>
				<td colspan=2><small><b>key status</td>
			</tr>
			<tr>
				<td><small><SELECT NAME=mv_dbconf_COLUMN_DEF_notnull>
	<OPTION VALUE=""> NULL is OK
	<OPTION VALUE="1" $notnull> NOT NULL
</SELECT></td>
				<td colspan=2><small><SELECT NAME=mv_dbconf_COLUMN_DEF_key>
	<OPTION VALUE=""> not primary key
	<OPTION VALUE="1" $pkey> PRIMARY KEY
</SELECT></td>
			</tr>
			</table>
		</td>
	</tr>
EOF


	}

	push @out, <<EOF;
		</table></td>
	</tr>
EOF

}
	


	%misc = %Misc_set;

	if($current_sql or ($new and $base_sql)) {
		for(keys %Misc_set_sql) {
			$misc{$_} = $Misc_set_sql{$_};
		}
	}

	$wid = '<TABLE>';
	for(sort keys %misc) {
		next unless $misc{$_};
		$wid .= "<TR><TD>$_</TD><TD>";
		$wid .= $Tag->widget( { 
								type => 'select',
								default => $ref->{$_},
								passed => $misc{$_},
								name => "mv_dbconf_$_",
							} );
		$wid .="</TD></TR>";
	}
	$wid .= "</TABLE>";

	push @out, <<EOF;
	<tr>
		<th valign=top align=left>Extra settings</th>
		<td>$wid</td>
	</tr>
EOF

	if($current_sql or ($new and $base_sql) ) {
		my @post;
		if ($ref->{POSTCREATE}) {
			@post = @{$ref->{POSTCREATE}};
			push @post, "";
		}
		my $post = join ";\n", @post;
		my $extra = '';
		if (! $CGI->{custom_table_create}) {
			$extra = qq{<BR>};
			$extra .= $Tag->page( {
									href=> '@@MV_PAGE@@',
									form => "
										custom_table_create=1
										ui_remember=1
									",
								} );
			$extra .= "Custom create SQL</A>";
		}
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>SQL after creation$extra</th>
		<td><TEXTAREA NAME="mv_dbconf_POSTCREATE" ROWS=3 COLS=50>$post</TEXTAREA></td>
	</tr>
EOF
	}

	if($CGI->{custom_table_create} and ($current_sql or ($new and $base_sql)) ) {
		push @out, <<EOF;
	<tr>
		<th valign=top align=left>Custom table creation SQL</th>
		<td><TEXTAREA NAME="mv_dbconf_CREATE_SQL" ROWS=12 COLS=50>$ref->{CREATE_SQL}</TEXTAREA></td>
	</tr>
EOF
	}

	%misc = %Adv_set;

	if($current_sql or ($new and $base_sql)) {
		for(keys %Adv_set_sql) {
			$misc{$_} = $Adv_set_sql{$_};
		}
		for(@Adv_set_sql_text) {
			$misc{$_} = '';
		}
	}

	$wid = '<TABLE>';
	for(sort keys %misc) {
		$wid .= "<TR><TD>$_</TD><TD>";
		my $type = $misc{$_} ? 'select' : 'text';
		$wid .= $Tag->widget( { 
							type => $type,
							default => $ref->{$_},
							passed => $misc{$_} || 1,
							name => "mv_dbconf_$_",
						} );
		$wid .="</TD></TR>";
	}
	$wid .= "</TABLE>";

	push @out, <<EOF;
	<tr>
		<th valign=top align=left>Advanced settings<br><small>(must uncomment to set in configuration)</th>
		<td>$wid</td>
	</tr>
EOF


	push @out, <<EOF;
		</table>
	</TD>
</TR>
EOF


	return join "", @out;
[/perl]
	</TD>
</TR>

<TR>
  <TD BGCOLOR=__UI_C_TOPBLOCKBAR__ COLSPAN=3><img src="@_UI_IMG_@admin/bg.gif" width=__UI_MAIN_WIDTH__ height=1></TD>
</TR>

</TABLE>

</td></tr>

</table>
</FORM>
</center>


<!-- ----- END REAL STUFF ----- -->

@_UI_STD_FOOTER_@
<!-- page: @@MV_PAGE@@ -->
